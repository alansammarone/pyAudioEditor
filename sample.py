''' 
	A Sample instance represents a piece of sound that can be edited.
	Before editing, it can be initialized by loading an external wav file, 
	or generated by a fixed or time-dependent oscillator.

'''

import numpy as np
import math as m
from scipy import sparse
from inspect import isfunction
import scipy.io.wavfile

class Sample:

	sampleRate = 0
	timeDuration = 0
	sampleCount = 0
	sampleDuration = 0

	waveType = 0 # 1 = Sine wave, 2 = Triangle wave, 3 = Square wave
	frequencyType = 0 # 1 = Constant frequency, 2 = function-based frequency, None = doesn't apply (when sample is loaded from file)
	frequencySource = None

	waveForm = None # The amplitude as a function of time

	def __init__(self):
		self.sampleRate = 44100 
		self.timeDuration = 1.0
		self.sampleCount = self.sampleRate*self.timeDuration
		self.sampleDuration = 1.0/self.sampleRate


	def setFrequency(self, frequency, volume=1.0):
		if type(frequency) is int:
			self.frequencyType = 1
			self.frequencySource = frequency
		elif isfunction(frequency):
			self.frequencyType = 2
			self.frequencySource = frequency
		else:
			raise Exception("Frequency of sample must be either an integer or a function of time.")

		self.buildWaveForm()

	def setDuration(self, t):
		if type(t) is not int and type(t) is not float:
			raise Exception("Time must be either an integer or a float. Received %s." % type(t))

		self.timeDuration = t
		self.sampleCount = t*self.sampleRate

	def leftPad(self, t):
		if type(t) is not int and type(t) is not float:
			raise Exception("Time must be either an integer or a float. Received %s." % type(t))

		padSamples = t*self.sampleRate
		self.waveForm = np.concatenate((np.zeros((1, padSamples)), self.waveForm), axis=1)
		self.setDuration(self.timeDuration + t)


	def rightPad(self, t):
		if type(t) is not int and type(t) is not float:
			raise Exception("Time must be either an integer or a float. Received %s." % type(t))

		padSamples = t*self.sampleRate
		self.waveForm = np.concatenate((self.waveForm, np.zeros((1, padSamples))), axis=1)
		self.setDuration(self.timeDuration + t)


	def padSample(self, t):
		if type(t) is not int and type(t) is not float:
			raise Exception("Time must be either an integer or a float. Received %s." % type(t))
		self.leftPad(t)
		self.rightPad(t)

	def leftTrim(self):
		return None

	def rightTrim(self):
		return None

	def trimSample(self):
		return None

	def applyEchoFilter(self, d, s):

		m = self.makeEchoMatrix(d, s)
		self.waveForm = m.T.dot(self.waveForm.T).T


	def applyLoop(self, loop_times=1):
		self.waveForm = np.concatenate(tuple(self.waveForm for x in xrange(loop_times)), axis=1)
		self.setDuration(self.timeDuration*loop_times)

	def addSample(self, sample, start_time=0):

		startAtSample = int(start_time * self.sampleRate)
		endAtSample = int(startAtSample + sample.sampleCount)

		if endAtSample > self.sampleCount:
			self.rightPad((endAtSample - self.sampleCount)/float(self.sampleRate))

		for s in xrange(startAtSample, endAtSample):
			self.waveForm[0][s] = (self.waveForm[0][s] + sample.waveForm[0][s-startAtSample])/2.0


	def loadFromFile(self, fname):
		wavFile = scipy.io.wavfile.read(fname)


		self.waveForm = np.array([wavFile[1]/float(2**15)])


		self.setDuration(float(self.waveForm.shape[1])/wavFile[0])

		
	def makeEchoMatrix(self, d, s):

		n = self.waveForm.shape[1]
		d = int(d*self.sampleRate)
	
		rows = []
		cols = []
		data = []
	
		for i in xrange(n-d):
			
			rows.append(i)
			cols.append(i)
			data.append(1.0)

			rows.append(i)
			cols.append(d+i)
			data.append(s)
	
		for i in xrange(n-d, n):
			rows.append(i)
			cols.append(i)
			data.append(1.0)


		return sparse.csr_matrix((data, (rows, cols)), shape=(n, n))

	@staticmethod
	def sineWaveFunction(t, f):
		return m.sin(2*m.pi*t*f)

	@classmethod
	def vectorizedSineWaveFunction(cls, tArray, f):
		vectorizedFunction = np.vectorize(cls.sineWaveFunction)
		return vectorizedFunction(tArray, f)

	def buildWaveForm(self):
		t = np.array([[s*self.sampleDuration for s in xrange(int(self.sampleCount))]])


		if self.frequencyType == 1:	self.waveForm = self.vectorizedSineWaveFunction(t, self.frequencySource) # Constant frequency, easy case:
		elif self.frequencyType == 2: # Hard case, varying frequency. We need to numericaly integrate the frequency function.
			frequencyArray = [0]
			for i in xrange(int(self.sampleCount)): frequencyArray.append(frequencyArray[-1] + self.sampleDuration*self.frequencySource(t[0][i])) 
			frequencyArray.pop(0)
			self.waveForm = self.vectorizedSineWaveFunction(np.array([frequencyArray]), 1)			








'''


s = Sample()
s.loadFromFile("kicks/kick1.wav")
print s.waveForm.shape
s.rightPad(1.0)

s1 = Sample()
s1.setDuration(.25)
s1.setFrequency(500)



s = Sample()

def f(t):
	return 40 + t*10

s.setFrequency(60)



s.addSample(s1, .75)
'''








